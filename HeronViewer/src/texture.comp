#version 430 core

layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

// ----------------------------------------------------------------------------
//
// uniforms
//
// ----------------------------------------------------------------------------

layout(rgba32f, binding = 0) uniform writeonly image2D imgOutput;
	
layout(binding=1) uniform readonly sampler2D texture1;

layout(rgba32f, binding = 2) uniform image2D vectorscope_texture;


uniform float[4] high;
uniform float[4] mid;
uniform float[4] low;
uniform float[4] expo;
uniform float[4] contrast;
uniform float[4] whites;

uniform float cdf[256];
uniform bool histogram_loaded;

shared uint local_bins[256];

float calcLum(vec3 v) {
    return dot(v, vec3(0.299, 0.587, 0.114));
}
float calcLum(vec4 v) {
    return calcLum(v.xyz);
}

vec4 clamp_pix(vec4 v) {
	if (calcLum(v) <= 0.0) {
		return vec4(0.0, 0.0, 0.0, 1);
	}
	if (calcLum(v) >= 1.0) {
		return vec4(1.0, 1.0, 1.0, 1);
	}
	return v;
}


vec3 hsv2rgb(vec3 c)
{
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

vec3 rgb2hsv(vec3 c)
{
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

float circle_atan(float x, float y) {
    if (x > 0) return atan(y/x);
    if (x < 0 && y >= 0) return atan(y/x) + 3.14;
    if (x < 0 && y < 0) return atan(y/x) - 3.14;
    if (x == 0 && y > 0) return 3.14/2.0;
    if (x == 0 && y < 0) return -3.14/2.0;
    return 0;
}


vec2 hsv2polar(vec3 c) {
    return vec2(sqrt(pow(c.x,2) + pow(c.y,2)), circle_atan(c.x,c.y));
}

vec2 polar2cart(vec2 c) {
    return vec2(c.x * cos(c.y), c.x * sin(c.y));
}

float edit_channel(float v, int chr) {
	vec4 result = vec4(0);
	float t = pow(2,expo[chr]) * v * (1 + whites[chr]);
	float val = (4 * pow((1-t),3) * t * (0.25 + low[chr] - contrast[chr])) + (6 * pow((1-t),2) * pow(t,2) * (0.5 + mid[chr])) + (4 * (1-t) * pow(t,3) * (0.75 + high[chr] + contrast[chr])) + (pow(t,4) * 1);
	return val;
}

float edit_channel_lum(float v) {
	return edit_channel(v, 0);
}

vec4 edit_channels(vec4 pix) {
	vec3 res = vec3(edit_channel(pix[2], 1),edit_channel(pix[1], 2),edit_channel(pix[0], 3));
	return vec4(edit_channel_lum(res[0]),edit_channel_lum(res[1]),edit_channel_lum(res[2]), 1);
}

vec4 pixelTransform(vec4 pix) {
	vec4 result = clamp_pix(edit_channels(pix));
    return result;
}

void main() {
    ivec2 texSize = textureSize(texture1, 0);
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);

    if (pixelCoord.x < 255 && pixelCoord.y < 255) {
        imageStore(vectorscope_texture, pixelCoord, vec4(vec3(0),1));
    }

    barrier();
    memoryBarrier();
  
    // Ensure the current invocation is within the texture bounds
    if (pixelCoord.x < texSize.x && pixelCoord.y < texSize.y) {
        vec4 texColor = texelFetch(texture1, pixelCoord, 0);
        texColor.x = pow(texColor.x,2.5);
        texColor.y = pow(texColor.y,2.5);
        texColor.z = pow(texColor.z,2.5);

        texColor = pixelTransform(texColor);

        if (histogram_loaded) {
            uint binIndex = uint(calcLum(texColor.bgr) * 255.0);
            //texColor = vec4(vec3(cdf[binIndex]), 1.0);
            //texColor = vec4(texColor.rgb * cdf[binIndex], 1.0);
        }

        imageStore(imgOutput, pixelCoord, texColor);



        vec3 hsv = rgb2hsv(texColor.rgb);
        ivec2 c = ivec2(polar2cart(vec2(hsv.y,hsv.x * 3.1459 * 2)) * 128);

        vec3 col = rgb2hsv(texColor.rgb);
        vec3 n = hsv2rgb(col);
        c += ivec2(128,128);
        imageStore(vectorscope_texture, c, vec4(n,1));
        
    }

}
#version 430 core

layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

// ----------------------------------------------------------------------------
//
// uniforms
//
// ----------------------------------------------------------------------------

layout(rgba32f, binding = 0) uniform image2D img;

layout(binding=1) uniform readonly sampler2D texture1;
	
layout(std430, binding=2) buffer hist {
    uint elements[];
};

layout(std430, binding=3) buffer hist_orig {
    uint elements_orig[];
};

layout(rgba32f, binding = 4) uniform image2D vectorscope_texture;
layout(rgba32f, binding = 5) uniform image2D waveform_texture;

uniform bool histogram_loaded;

shared uint local_bins[256];
shared uint orig_local_bins[256];


vec3 hsv2rgb(vec3 c)
{
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

vec3 rgb2hsv(vec3 c)
{
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

vec2 polar2cart(vec2 c) {
    return vec2(c.x * cos(c.y), c.x * sin(c.y));
}

float calcLum(vec3 v) {
    return dot(v, vec3(0.299, 0.587, 0.114));
}
float calcLum(vec4 v) {
    return calcLum(v.xyz);
}

void main() {
    ivec2 texSize = imageSize(img);
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);

    uint lid = gl_LocalInvocationID.x + gl_LocalInvocationID.y * 32;

    if (lid < 256) {
        local_bins[lid] = 0;
        if (!histogram_loaded) {
            orig_local_bins[lid] = 0;
        }
    }

    if (pixelCoord.y < 255) {
        if (pixelCoord.x < 255)
            imageStore(vectorscope_texture, pixelCoord, vec4(vec3(0),1));
        if (pixelCoord.x < 512)
            imageStore(waveform_texture, pixelCoord, vec4(vec3(0),1));
    }


    barrier();
    memoryBarrier();
  

    barrier();
    memoryBarrier();
	
  
    // Ensure the current invocation is within the texture bounds
    if (pixelCoord.x < texSize.x && pixelCoord.y < texSize.y) {
        vec4 texColor = imageLoad(img, pixelCoord);

        // Convert color to grayscale
        float grayscale = calcLum(texColor);
      
        // Convert grayscale value to histogram bin index
        // x 4 since we store hist values as L, R, G, B, ...
        uint binIndex = uint(grayscale * 255.0);

        //uint rIndex = uint(texColor.b * 255.0) * 4;
        //uint gIndex = uint(texColor.g * 255.0) * 4;
        //uint bIndex = uint(texColor.r * 255.0) * 4;

      
        // Atomic increment to update the histogram bin value
        atomicAdd(local_bins[binIndex], 1);
        
        //atomicAdd(local_bins[rIndex+1], 1);
        //atomicAdd(local_bins[gIndex+2], 1);
        //atomicAdd(local_bins[bIndex+3], 1);

        if (!histogram_loaded) {
            texColor = texelFetch(texture1, pixelCoord, 0);
            texColor.x = pow(texColor.x,2.5);
            texColor.y = pow(texColor.y,2.5);
            texColor.z = pow(texColor.z,2.5);
      
            // Convert color to grayscale
            grayscale = calcLum(texColor.bgr);
      
            // Convert grayscale value to histogram bin index
            binIndex = uint(grayscale * 255.0);
      
            // Atomic increment to update the histogram bin value
            atomicAdd(orig_local_bins[binIndex], 1);
        }

        vec3 hsv = rgb2hsv(texColor.rgb);
        ivec2 c = ivec2(polar2cart(vec2(hsv.y,hsv.x * 3.1459 * 2)) * 128);

        vec3 col = rgb2hsv(texColor.rgb);
        vec3 n = hsv2rgb(col);
        c += ivec2(128,128);
        imageStore(vectorscope_texture, c, vec4(n,1));

        ivec2 cc = ivec2(int((pixelCoord.x / float(texSize.x)) * 512), int(255 - uint(calcLum(texColor.bgr) * 255.0)));
        imageStore(waveform_texture, cc, vec4(n,1));
    }

    barrier();
    memoryBarrier();

    if (lid < 256) {
       atomicAdd(elements[lid], local_bins[lid]);
       if (!histogram_loaded) {
           atomicAdd(elements_orig[lid], orig_local_bins[lid]);
       }
    }
}
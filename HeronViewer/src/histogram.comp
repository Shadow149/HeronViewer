#version 430 core

#define SIZE 32

layout (local_size_x = SIZE, local_size_y = SIZE, local_size_z = 1) in;

// ----------------------------------------------------------------------------
//
// uniforms
//
// ----------------------------------------------------------------------------

layout(rgba32f, binding = 0) uniform image2D img;

layout(binding=1) uniform readonly sampler2D texture1;
	
layout(std430, binding=2) buffer hist {
    uint elements[];
};

layout(std430, binding=3) buffer hist_orig {
    uint elements_orig[];
};

layout(rgba32f, binding = 4) uniform image2D vectorscope_texture;
layout(rgba32f, binding = 5) uniform image2D waveform_texture;
layout(r32i, binding = 6) uniform coherent iimage2D waveform_acc;
layout(r32i, binding = 7) uniform coherent iimage2D vectorscope_acc;

uniform float cdf[256];
uniform bool histogram_loaded;
uniform float var_mult;
uniform bool bw;


shared uint local_bins[256];
shared uint orig_local_bins[256];



vec3 hsv2rgb(vec3 c)
{
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

vec3 rgb2hsv(vec3 c)
{
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

vec2 polar2cart(vec2 c) {
    return vec2(c.x * cos(c.y), c.x * sin(c.y));
}

float calcLum(vec3 v) {
    return dot(v, vec3(0.299, 0.587, 0.114));
}
float calcLum(vec4 v) {
    return calcLum(v.xyz);
}

void main() {
    ivec2 texSize = imageSize(img);
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);

    uint lid = gl_LocalInvocationID.x + gl_LocalInvocationID.y * SIZE;

    if (lid < 256) {
        local_bins[lid] = 0;
        if (!histogram_loaded) {
            orig_local_bins[lid] = 0;
        }
    }

    if (pixelCoord.x < 255 && pixelCoord.y < 255) {
        imageStore(vectorscope_texture, pixelCoord, vec4(vec3(0),1));
    }

    if (pixelCoord.x < 512 && pixelCoord.y < 255) {
        //imageStore(waveform_texture, pixelCoord, vec4(vec3(0),1));
        //imageAtomicAdd(waveform_acc, pixelCoord, 100);
        
        //imageStore(waveform_acc, pixelCoord, ivec4(ivec3(0),1));
        //imageAtomicAnd(waveform_acc, pixelCoord, 0);
        
        //imageAtomicExchange(waveform_acc, pixelCoord, 0);
        
        //imageStore(waveform_acc, cc, ivec4(ivec3(0),1));
    }

    barrier();
    memoryBarrier();
  
    // Ensure the current invocation is within the texture bounds
    if (pixelCoord.x < texSize.x && pixelCoord.y < texSize.y) {

        vec4 texColor = imageLoad(img, pixelCoord);

        // Convert color to grayscale
        float grayscale = calcLum(texColor);
      
        // Convert grayscale value to histogram bin index
        // x 4 since we store hist values as L, R, G, B, ...
        uint binIndex = uint(grayscale * 255.0);

        //uint rIndex = uint(texColor.b * 255.0) * 4;
        //uint gIndex = uint(texColor.g * 255.0) * 4;
        //uint bIndex = uint(texColor.r * 255.0) * 4;

      
        // Atomic increment to update the histogram bin value
        atomicAdd(local_bins[binIndex], 1);
        
        //atomicAdd(local_bins[rIndex+1], 1);
        //atomicAdd(local_bins[gIndex+2], 1);
        //atomicAdd(local_bins[bIndex+3], 1);

        if (!histogram_loaded) {
            texColor = texelFetch(texture1, pixelCoord, 0);
            texColor.x = pow(texColor.x,2.5);
            texColor.y = pow(texColor.y,2.5);
            texColor.z = pow(texColor.z,2.5);
      
            // Convert color to grayscale
            grayscale = calcLum(texColor.bgr);
      
            // Convert grayscale value to histogram bin index
            binIndex = uint(grayscale * 255.0);
      
            // Atomic increment to update the histogram bin value
            atomicAdd(orig_local_bins[binIndex], 1);
        }

        vec3 hsv = rgb2hsv(texColor.rgb);
        ivec2 c = ivec2(polar2cart(vec2(hsv.y,hsv.x * 3.1459 * 2)) * 128);

        c += ivec2(128,128);

        if (!bw) {
            ivec2 bar = ivec2( int( (float(pixelCoord.x)/float(texSize.x)) * 255 ), int( (float(pixelCoord.y)/float(texSize.y)) * 255 ));
            imageAtomicExchange(vectorscope_acc, bar, 0);
        }

        imageAtomicAdd(vectorscope_acc, c, 1);


        ivec2 foo = ivec2( int( (float(pixelCoord.x)/float(texSize.x)) * 512 ), int( (float(pixelCoord.y)/float(texSize.y)) * 255 ));
        imageAtomicExchange(waveform_acc, foo, 0);

        ivec2 cc = ivec2( int( min(float(pixelCoord.x)/float(texSize.x),1) * 511 ), int(254 - binIndex));
        imageAtomicAdd(waveform_acc, cc, 1);
    }

    barrier();
    memoryBarrier();

    if (lid < 256) {
       atomicAdd(elements[lid], local_bins[lid]);
       if (!histogram_loaded) {
           atomicAdd(elements_orig[lid], orig_local_bins[lid]);
       }
    }

    if (pixelCoord.x < 512 && pixelCoord.y < 255) {
        int count = imageLoad(waveform_acc, pixelCoord).x;
        imageStore(waveform_texture, pixelCoord, vec4(vec3(count/(var_mult*70)),1));
    }
    if (pixelCoord.x < texSize.x && pixelCoord.y < texSize.y && !bw) {
        vec4 texColor = imageLoad(img, pixelCoord);
        vec3 hsv = rgb2hsv(texColor.rgb);
        ivec2 c = ivec2(polar2cart(vec2(hsv.y,hsv.x * 3.1459 * 2)) * 128);

        c += ivec2(128,128);
        int count = imageLoad(vectorscope_acc, c).x;
        imageStore(vectorscope_texture, c, vec4(texColor.rgb * min(1,count/(var_mult*120)),1));
    }
}